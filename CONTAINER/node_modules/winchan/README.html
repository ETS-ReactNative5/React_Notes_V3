<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>README</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
</head>
<body>
<h2 id="an-abstraction-for-opening-browser-windows-cross-domain">An abstraction for opening browser windows cross domain</h2>
<p>Here’s the scenario: You want to build a secure means of some untrusted site opening a window, which loads content at a trusted site. Then you want the untrusted dude to be able to pass in parameters. Then you want the trusted code to do any amount of stuff, and return a response.</p>
<p>This kinda thing is what lots of services on the web do, services like <a href="https://browserid.org">BrowserID</a>.</p>
<p>Trouble is that this is stupidly hard:</p>
<ul>
<li>Mobile Firefox doesn’t like it when you open windows with window options</li>
<li>IE 8 &amp; 9 don’t even allow postMessage between opener and window</li>
<li>iOS 5 has some interesting optimizations that can bite you if not careful</li>
<li>you should tightly check origins to avoid classes of attacks</li>
<li>you probably will have to add stuff in the DOM, you should make sure you can clean this up and avoid introducing fragile code</li>
</ul>
<p>WinChan is an abstraction to solve these problems and make it easy to open windows which take and return parameters and load content cross domain.</p>
<h2 id="browser-support">Browser Support</h2>
<p>WinChan is expected to work on:</p>
<ul>
<li>winxp - win7 on IE8 and IE9</li>
<li>windows, linux, osx - Chrome, Firefox, Opera, and Safari</li>
<li>Android’s “native” browser - 2.1, 2.2, 2.3.4, 3.2 (and presumably newer)</li>
<li>Fennec on Android</li>
</ul>
<h2 id="usage">Usage</h2>
<p>For the site spawning the window, the “untrusted” or “client” code:</p>
<pre><code>WinChan.open({
  url: &quot;http://trusted.host/dialog.html&quot;,
  relay_url: &quot;http://trusted.host/relay.html&quot;,
  window_features: &quot;menubar=0,location=0,resizable=0,scrollbars=0,status=0,dialog=1,width=700,height=375&quot;,
  params: {
    these: &quot;things&quot;,
    are: &quot;input parameters&quot;
  }
}, function(err, r) {
  // err is a string on failure, otherwise r is the response object
});</code></pre>
<p>For the site providing the window, the “trusted” code:</p>
<pre><code>WinChan.onOpen(function(origin, args, cb) {
  // origin is the scheme+host+port that cause window invocation,
  // it can be trusted

  // args are the untrusted arguments provided by the calling site

  // and cb you can call within the function, or synchronously later.
  // calling it indicated the window is done and can be closed.
  cb({
    &quot;these things&quot;: &quot;are the response&quot;
  });
});</code></pre>
<p>Finally, you’ll notice that the trusted code needs to host ‘relay.html’ somewhere (required for IE support).</p>
<h2 id="running-examples">Running Examples</h2>
<p>there’s a little tiny webserver in-tree to let you run the examples. You’ll need node.js and npm installed. Once you have these, just:</p>
<pre><code>$ npm i
$ scripts/run_example.js</code></pre>
<p>Now load <code>http://127.0.0.1:8100/example</code> (or the more complicated example which demonstrates navigation away and back in window at <code>http://127.0.0.1:8100/complex_example</code></p>
<h2 id="running-unit-tests">Running Unit Tests</h2>
<p>node.js and npm are required to run the unit tests. Once installed</p>
<pre><code>$ npm i
$ scripts/run_example.js</code></pre>
<p>And open <code>http://127.0.0.1:8100/test</code> in your favorite web browser.</p>
<p><strong>NOTE:</strong> You’ll need to disable popup blocking for localhost to run tests!</p>
<h2 id="testing-over-the-network">Testing over the network</h2>
<p>the <code>run_example.js</code> script will bind whatever IP is in the <code>IP_ADDRESS</code> env var. So to test over the network:</p>
<pre><code>$ npm i
$ IP_ADDRESS=&lt;my external IP&gt; scripts/run_example.js</code></pre>
<p>(repace <code>&lt;my external IP&gt;</code> with <em>your</em> IP address)</p>
<p>then hit <code>http://&lt;my external IP&gt;:8100/test</code></p>
</body>
</html>
